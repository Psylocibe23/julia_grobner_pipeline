

# This file was *autogenerated* from the file scripts/construct_HFE_parallelized.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2048 = Integer(2048); _sage_const_256 = Integer(256); _sage_const_0 = Integer(0); _sage_const_24 = Integer(24); _sage_const_1 = Integer(1); _sage_const_0p6 = RealNumber('0.6'); _sage_const_2 = Integer(2); _sage_const_0p70 = RealNumber('0.70'); _sage_const_0p60 = RealNumber('0.60'); _sage_const_20 = Integer(20); _sage_const_16 = Integer(16); _sage_const_1023 = Integer(1023); _sage_const_32 = Integer(32); _sage_const_3 = Integer(3); _sage_const_4 = Integer(4); _sage_const_5 = Integer(5); _sage_const_6 = Integer(6); _sage_const_7 = Integer(7); _sage_const_8 = Integer(8)###############################################################################
# construct_HFE_parallelized.sage — Classical HFE instance generator for GF(2)
#
# - True HFE: F(X) uses only exponents 2^i and 2^i+2^j (i<j), ≤ D
# - Outputs pipeline .in, a human log, and a secret log (F,S,T,secret)
# - Speedups:
#     • Build public system directly in F2[x] via Frobenius (no K[x] blow-up)
#     • Precompute ∂p_i/∂x_j once per (S,T)
#     • Parallel secret probing (auto-tuned worker count) with early cancel
# - Safety:
#     • Skips if output already exists unless forced
#     • Cancels outstanding workers immediately on success
#
# Optional dev check:
#   Set HFE_SANITY=1 in env to cross-check fast path vs slow path on random
#   evaluation points (costly; use sparingly just to reassure yourself).
###############################################################################

import sys, os, time, multiprocessing
import random as pyrand
from concurrent.futures import ProcessPoolExecutor, as_completed
from sage.all import *

# ============================ Utilities ======================================

def ensure_dir_for(path):
    d = os.path.dirname(path)
    if d and not os.path.exists(d):
        os.makedirs(d)

def now_str():
    return time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())

def log_write(L, s):
    if L is not None:
        L.write(s + "\n"); L.flush()

def _is_unset(s):
    return s is None or str(s).strip().lower() in {"", "-", "default", "none"}

def _parse_opt(argv, idx, caster, default):
    if len(argv) <= idx: return default
    tok = argv[idx].strip()
    if _is_unset(tok): return default
    return caster(tok)

def _parse_bool(tok, default=False):
    if tok is None: return default
    t = str(tok).strip().lower()
    if t in {"1","true","t","yes","y"}:  return True
    if t in {"0","false","f","no","n"}:  return False
    return default

def pick_workers(cli_workers=None, max_secret_tries=_sage_const_2048 , batch_size=_sage_const_256 , n=_sage_const_0 ):
    """
    Conservative worker selection:
      - tiny n (<24) → 1 worker (avoid pool overhead)
      - otherwise cap by ceil(max_secret_tries / batch_size)
      - otherwise use SLURM_CPUS_PER_TASK or os.cpu_count()
    """
    if n and n < _sage_const_24 :
        return _sage_const_1 
    cap_by_batches = max(_sage_const_1 , (max_secret_tries + batch_size - _sage_const_1 ) // batch_size)

    if cli_workers is not None and not _is_unset(cli_workers):
        try:
            return max(_sage_const_1 , min(int(cli_workers), cap_by_batches))
        except Exception:
            pass

    env = os.environ.get("SLURM_CPUS_PER_TASK")
    if env:
        try:
            return max(_sage_const_1 , min(int(env), cap_by_batches))
        except Exception:
            pass

    try:
        return max(_sage_const_1 , min(os.cpu_count() or _sage_const_1 , cap_by_batches))
    except Exception:
        return _sage_const_1 

# ====================== HFE univariate over K = GF(2^n) ======================

def random_hfe_polynomial(K, n, D, prob_quad=_sage_const_0p6 , prob_lin=_sage_const_0p6 ,
                          must_have_quad=True, must_have_lin=True):
    """
    F(X) ∈ K[X], HFE-degree ≤ D.
      • linearized: X^(2^i) with 2^i ≤ D
      • true quad : X^(2^i+2^j), i<j, ≤ D  (i=j collapses to linearized in char 2)
    """
    R = PolynomialRing(K, names=('X',)); (X,) = R._first_ngens(1)
    F = R(_sage_const_0 )

    # admissible 2^i
    lin_is, e, i = [], _sage_const_1 , _sage_const_0 
    while i < n and e <= D:
        lin_is.append(i)
        i += _sage_const_1 ; e <<= _sage_const_1 

    # admissible 2^i + 2^j, i<j
    quad_pairs = []
    for i in range(n):
        e_i = _sage_const_1  << i
        if e_i > D: break
        for j in range(i+_sage_const_1 , n):
            e_ij = e_i + (_sage_const_1  << j)
            if e_ij > D: break
            quad_pairs.append((i, j))

    have_quad = False; have_lin = False

    # true quadratic terms
    for (i, j) in quad_pairs:
        if pyrand.random() < prob_quad:
            c = K.random_element()
            if c != _sage_const_0 :
                F += c * X**((_sage_const_1  << i) + (_sage_const_1  << j))
                have_quad = True

    # linearized terms
    for i in lin_is:
        if pyrand.random() < prob_lin:
            c = K.random_element()
            if c != _sage_const_0 :
                F += c * X**(_sage_const_1  << i)
                have_lin = True

    # constant
    c0 = K.random_element()
    if c0 != _sage_const_0 :
        F += c0

    # enforce at least one of each (if admissible)
    if must_have_quad and not have_quad and quad_pairs:
        i, j = quad_pairs[_sage_const_0 ]
        F += K(_sage_const_1 ) * X**((_sage_const_1  << i) + (_sage_const_1  << j))
        have_quad = True
    if must_have_lin and not have_lin and lin_is:
        i = lin_is[_sage_const_0 ]
        F += K(_sage_const_1 ) * X**(_sage_const_1  << i)
        have_lin = True

    return F, have_quad, have_lin

# =================== Frobenius-aware fast public builder =====================

def fast_public_from_F_and_S(K, a, R, A_S, b_S, F_univar, n, D):
    """
    Build y(x) ∈ K^n with components in F2[x] directly, using Frobenius:
      s(x) = c0 + sum_v c_v x_v,  c_• ∈ K determined by A_S,b_S and basis {a^k}
      For term X^{2^i}:      s^{2^i} = c0^{2^i} + sum_v (c_v^{2^i}) x_v
      For term X^{2^i+2^j}:  expand s^{2^i} * s^{2^j} into const/linear/quad in x.
    Split each K-coefficient onto the power basis to fill the n coordinates.

    Returns list y[0..n-1] ⊂ F2[x].
    """
    F2 = R.base_ring()
    x = R.gens()

    # s(x) coefficients in K via the fixed basis {a^k}
    c = [K(_sage_const_0 )]*(n+_sage_const_1 )  # c[0]=constant, c[v+1] for x_v
    for k in range(n):
        ak = a**k
        if int(b_S[k]) != _sage_const_0 :
            c[_sage_const_0 ] += ak
        for v in range(n):
            if int(A_S[k,v]) != _sage_const_0 :
                c[v+_sage_const_1 ] += ak

    # Determine max Frobenius power 2^t ≤ D
    max_t = _sage_const_0 ; e = _sage_const_1 
    while (e << _sage_const_1 ) <= D:
        e <<= _sage_const_1 ; max_t += _sage_const_1 

    # Precompute c_i^{2^t}
    c_pow = [[K(_sage_const_0 )]*(n+_sage_const_1 ) for _ in range(max_t+_sage_const_1 )]
    for i in range(n+_sage_const_1 ):
        val = c[i]
        c_pow[_sage_const_0 ][i] = val
        for t in range(_sage_const_1 , max_t+_sage_const_1 ):
            val = val**_sage_const_2 
            c_pow[t][i] = val

    # Accumulators for y ∈ K^n but stored as F2[x] polys via basis splitting
    y = [R(_sage_const_0 ) for _ in range(n)]
    zero_mon = tuple(_sage_const_0  for _ in range(n))

    def add_Kcoef_mon(Kcoef, mon_tuple):
        if Kcoef == _sage_const_0 :
            return
        vec = Kcoef._vector_()  # K→F2^n on the fixed basis
        mono = R({mon_tuple: _sage_const_1 })
        for t in range(n):
            if int(vec[t]) != _sage_const_0 :
                y[t] += mono

    # Traverse terms of F(X); in a univariate ring Sage uses int exponents
    for exp, Kcoef in F_univar.dict().items():
        eX = int(exp)

        if eX == _sage_const_0 :
            # constant term
            add_Kcoef_mon(Kcoef, zero_mon)
            continue

        # linearized 2^i?
        if (eX & (eX - _sage_const_1 )) == _sage_const_0 :  # power of two
            i = eX.bit_length() - _sage_const_1 
            c0i = c_pow[i][_sage_const_0 ]
            if c0i != _sage_const_0 :
                add_Kcoef_mon(Kcoef * c0i, zero_mon)
            for v in range(n):
                Cv = c_pow[i][v+_sage_const_1 ]
                if Cv != _sage_const_0 :
                    mon = tuple(_sage_const_1  if j==v else _sage_const_0  for j in range(n))
                    add_Kcoef_mon(Kcoef * Cv, mon)
            continue

        # quadratic 2^i+2^j (i<j)
        bits = []
        tmp = eX; pos = _sage_const_0 
        while tmp:
            if (tmp & _sage_const_1 ) != _sage_const_0 :
                bits.append(pos)
            tmp >>= _sage_const_1 ; pos += _sage_const_1 
        if len(bits) != _sage_const_2 :
            # HFE shouldn't introduce other exponents; skip if present
            continue
        i, j = bits[_sage_const_0 ], bits[_sage_const_1 ]
        c0i, c0j = c_pow[i][_sage_const_0 ], c_pow[j][_sage_const_0 ]

        # const*const
        if c0i != _sage_const_0  and c0j != _sage_const_0 :
            add_Kcoef_mon(Kcoef * c0i * c0j, zero_mon)

        # const*var and var*const
        for v in range(n):
            Ci_v = c_pow[i][v+_sage_const_1 ]
            Cj_v = c_pow[j][v+_sage_const_1 ]
            if c0i != _sage_const_0  and Cj_v != _sage_const_0 :
                mon = tuple(_sage_const_1  if t==v else _sage_const_0  for t in range(n))
                add_Kcoef_mon(Kcoef * c0i * Cj_v, mon)
            if c0j != _sage_const_0  and Ci_v != _sage_const_0 :
                mon = tuple(_sage_const_1  if t==v else _sage_const_0  for t in range(n))
                add_Kcoef_mon(Kcoef * c0j * Ci_v, mon)

        # var*var
        for v in range(n):
            Ci_v = c_pow[i][v+_sage_const_1 ]
            if Ci_v == _sage_const_0 : continue
            for u in range(n):
                Cj_u = c_pow[j][u+_sage_const_1 ]
                if Cj_u == _sage_const_0 : continue
                if v == u:
                    mon = tuple(_sage_const_1  if t==v else _sage_const_0  for t in range(n))
                else:
                    mon = tuple(_sage_const_1  if (t==v or t==u) else _sage_const_0  for t in range(n))
                add_Kcoef_mon(Kcoef * Ci_v * Cj_u, mon)

    return y

# ================= Project K[x] → n coordinates in F2[x] (slow; for sanity) ==

def coords_over_F2(poly_Kx, K, a, n, R_F2):
    coords = [R_F2(_sage_const_0 ) for _ in range(n)]
    for mon, coeff in poly_Kx.dict().items():
        cvec = K(coeff)._vector_()
        mon_R = R_F2({mon: _sage_const_1 })
        for t in range(n):
            if cvec[t] != _sage_const_0 :
                coords[t] += mon_R
    return coords

def boolean_reduce(poly, R):
    terms = {}
    for mon, coeff in poly.dict().items():
        if coeff == _sage_const_0 :
            continue
        red_mon = tuple(_sage_const_1  if e > _sage_const_0  else _sage_const_0  for e in mon)
        terms[red_mon] = terms.get(red_mon, R.base_ring()(_sage_const_0 )) + coeff
    return R(terms)

# ================= Jacobian helpers: precompute once per (S,T) ================

def precompute_jacobian_derivatives(polys, R):
    xs = R.gens()
    n = len(xs)
    return [[polys[i].derivative(xs[j]) for j in range(n)] for i in range(n)]

def jacobian_rank_at_from_derivs(derivs, R, x_star):
    F2 = R.base_ring(); xs = R.gens(); n = len(xs)
    subst = {xs[j]: F2(int(x_star[j])) for j in range(n)}
    J = Matrix(F2, n, n)
    for i in range(n):
        for j in range(n):
            J[i, j] = F2(derivs[i][j].subs(subst))
    return J.rank()

# ============================== Secret log ====================================

def write_secret_log(secret_logfile, n, K, F_univar, A_S, b_S, A_T, b_T, secret_vec):
    ensure_dir_for(secret_logfile)
    with open(secret_logfile, "w") as S:
        S.write(f"Secret log — {now_str()}\n")
        S.write(f"Field: GF(2^{n})\n")
        S.write(f"Modulus polynomial: {K.modulus()}\n")
        S.write(f"F(X) = {F_univar}\n")
        S.write("A_S =\n")
        for i in range(A_S.nrows()):
            S.write("[" + " ".join(str(int(A_S[i,j])) for j in range(A_S.ncols())) + "]\n")
        S.write("b_S = (" + ", ".join(str(int(b)) for b in b_S) + ")\n")
        S.write("A_T =\n")
        for i in range(A_T.nrows()):
            S.write("[" + " ".join(str(int(A_T[i,j])) for j in range(A_T.ncols())) + "]\n")
        S.write("b_T = (" + ", ".join(str(int(b)) for b in b_T) + ")\n")
        S.write("Secret = [" + ", ".join(str(int(b)) for b in secret_vec) + "]\n")

# ================= Parallel secret probing (via fork) =========================

_GLOBALS = {"derivs": None, "R": None, "n": None}

def _install_worker_state(derivs, R, n):
    _GLOBALS["derivs"] = derivs
    _GLOBALS["R"]      = R
    _GLOBALS["n"]      = n

def _probe_batch(batch_size, rank_min, seed=None):
    if seed is not None:
        pyrand.seed(seed)

    derivs = _GLOBALS["derivs"]; R = _GLOBALS["R"]; n = _GLOBALS["n"]
    if derivs is None or R is None or n is None:
        return {"found": False, "best_rank": -_sage_const_1 , "best_x": None}

    best_rank = -_sage_const_1 
    best_x    = None

    for _ in range(batch_size):
        x_tuple = tuple(pyrand.getrandbits(_sage_const_1 ) for _ in range(n))
        rankJ = jacobian_rank_at_from_derivs(derivs, R, x_tuple)

        if rankJ > best_rank:
            best_rank, best_x = rankJ, x_tuple
        if rankJ >= rank_min:
            return {"found": True, "x": x_tuple, "rank": rankJ,
                    "best_rank": best_rank, "best_x": best_x}

    return {"found": False, "best_rank": best_rank, "best_x": best_x}

# ========================= Builder ============================================

def build_and_export_instance(n, D, out_infile, seed=None,
                              prob_quad=_sage_const_0p70 , prob_lin=_sage_const_0p60 ,
                              max_maps=_sage_const_20 , max_secret_tries=_sage_const_2048 ,
                              rank_min=None, allow_fallback=False,
                              logfile=None, secret_logfile=None,
                              verbose=False, workers=None, batch_size=_sage_const_256 ):

    L = None
    if logfile:
        ensure_dir_for(logfile)
        L = open(logfile, "w")
        log_write(L, f"HFE generation start — {now_str()}")
        log_write(L, f"Params: n={n}, D={D}, prob_quad={prob_quad}, prob_lin={prob_lin}, "
                     f"max_maps={max_maps}, max_secret_tries={max_secret_tries}, "
                     f"rank_min={'auto' if rank_min is None else rank_min}, "
                     f"allow_fallback={allow_fallback}")

    try:
        if seed is not None:
            set_random_seed(int(seed))
            pyrand.seed(int(seed))
            log_write(L, f"Seed set to {int(seed)}")

        if rank_min is None:
            rank_min = max(_sage_const_0 , n - _sage_const_1 )

        F2 = GF(_sage_const_2 )
        K = GF(_sage_const_2 **n, names=('a',)); (a,) = K._first_ngens(1)
        modulus = K.modulus()
        names = tuple(f"x{i}" for i in range(n))
        R = PolynomialRing(F2, n, names=names)
        XK = PolynomialRing(K, n, names=names)  # used only if HFE_SANITY=1
        x_R  = R.gens()
        x_K  = XK.gens()

        F_univar, have_quad, have_lin = random_hfe_polynomial(
            K, n, D, prob_quad=prob_quad, prob_lin=prob_lin,
            must_have_quad=True, must_have_lin=True
        )
        log_write(L, f"F has true quadratic? {have_quad}; linearized? {have_lin}")

        def rnd_inv(n, F2):
            while True:
                M = random_matrix(F2, n, n)
                if M.is_invertible():
                    return M

        best = {"rank": -_sage_const_1 , "bundle": None}  # (A_S,b_S,A_T,z0_R,x_star,degs)

        # Compute worker count HERE with auto-tuning
        W = pick_workers(workers, max_secret_tries=max_secret_tries, batch_size=batch_size, n=n)
        if L: log_write(L, f"Workers: {W}   (batch_size per task: {batch_size})")

        for amap in range(_sage_const_1 , max_maps+_sage_const_1 ):
            A_S = rnd_inv(n, F2)
            b_S = vector(F2, [F2.random_element() for _ in range(n)])
            A_T = rnd_inv(n, F2)

            # ---------- FAST public build via Frobenius ----------
            log_write(L, f"[map {amap}] building public polynomials via Frobenius fast path ...")
            t0 = time.time()
            y_vec_R = fast_public_from_F_and_S(K, a, R, A_S, b_S, F_univar, n, D)

            # z0 = A_T * y (no constant yet), then boolean-reduce
            z0_R = []
            for i in range(n):
                acc = R(_sage_const_0 )
                for j in range(n):
                    if int(A_T[i, j]) != _sage_const_0 :
                        acc += y_vec_R[j]
                z0_R.append(boolean_reduce(acc, R))

            log_write(L, f"[map {amap}] public system built in {time.time()-t0:.2f}s")
            degs = [p.total_degree() for p in z0_R]
            maxdeg = max(degs) if degs else -_sage_const_1 
            log_write(L, f"[map {amap}] public max degree after Boolean: {maxdeg}")

            if maxdeg < _sage_const_2 :
                log_write(L, f"[map {amap}] skipped: maxdeg < 2")
                continue

            # ---------- Optional sanity: compare with slow path on random points ----------
            if os.environ.get("HFE_SANITY") == "1":
                s_vec_K = []
                for k in range(n):
                    expr = XK(_sage_const_0 )
                    for j in range(n):
                        if int(A_S[k, j]) != _sage_const_0 : expr += x_K[j]
                    if int(b_S[k]) != _sage_const_0 : expr += _sage_const_1 
                    s_vec_K.append(expr)
                sK = sum(s_vec_K[k] * (a**k) for k in range(n))
                yK = F_univar(sK)
                y_vec_R_slow = coords_over_F2(yK, K, a, n, R)
                z0_R_slow = []
                for i in range(n):
                    acc = R(_sage_const_0 )
                    for j in range(n):
                        if int(A_T[i, j]) != _sage_const_0 : acc += y_vec_R_slow[j]
                    z0_R_slow.append(boolean_reduce(acc, R))
                import random as _r
                xs = R.gens()
                for tcheck in range(_sage_const_16 ):
                    pt = {xs[k]: F2(_r.getrandbits(_sage_const_1 )) for k in range(n)}
                    for p_fast, p_slow in zip(z0_R, z0_R_slow):
                        if p_fast.subs(pt) != p_slow.subs(pt):
                            raise RuntimeError("SANITY FAIL: fast != slow on some point.")
                log_write(L, f"[map {amap}] SANITY: fast public == slow public on 16 random points")

            # ---------- Jacobian precompute + parallel probing ----------
            derivs = precompute_jacobian_derivatives(z0_R, R)
            _install_worker_state(derivs, R, n)

            remaining = max_secret_tries
            success   = None           # (x_tuple, rankJ)
            best_rank_seen = -_sage_const_1 
            best_point     = None

            if W <= _sage_const_1 :
                t = _sage_const_0 
                while remaining > _sage_const_0 :
                    bs = min(batch_size, remaining)
                    res = _probe_batch(bs, rank_min, seed=None)
                    remaining -= bs; t += bs
                    if res.get("found"):
                        success = (tuple(res["x"]), int(res["rank"]))
                        break
                    if res["best_rank"] > best_rank_seen:
                        best_rank_seen, best_point = int(res["best_rank"]), tuple(res["best_x"])
                    if (t & _sage_const_1023 ) == _sage_const_0 :
                        log_write(L, f"[map {amap}] probe {t}/{max_secret_tries} — best rank so far {best_rank_seen}")
            else:
                ctx = multiprocessing.get_context("fork")
                with ProcessPoolExecutor(max_workers=W, mp_context=ctx) as ex:
                    futures = set()
                    seed_base = int(time.time()) ** pyrand.getrandbits(_sage_const_32 )

                    def submit_some():
                        nonlocal remaining, futures
                        while remaining > _sage_const_0  and len(futures) < W:
                            bs = min(batch_size, remaining)
                            seed = seed_base + remaining
                            fut = ex.submit(_probe_batch, bs, rank_min, seed)
                            futures.add(fut)
                            remaining -= bs

                    submit_some()
                    while futures and success is None:
                        done = []
                        for fut in as_completed(futures, timeout=None):
                            done.append(fut)
                            try:
                                res = fut.result()
                            except Exception:
                                res = {"found": False, "best_rank": -_sage_const_1 , "best_x": None}

                            if res.get("found"):
                                success = (tuple(res["x"]), int(res["rank"]))
                                break

                            if res["best_rank"] > best_rank_seen:
                                best_rank_seen, best_point = int(res["best_rank"]), tuple(res["best_x"])

                        for fut in done:
                            futures.discard(fut)

                        if success is None:
                            submit_some()

                        probed = max_secret_tries - remaining
                        if (probed & _sage_const_1023 ) == _sage_const_0 :
                            log_write(L, f"[map {amap}] probe {probed}/{max_secret_tries} — best rank so far {best_rank_seen}")

                    if success is not None:
                        for fut in futures:
                            fut.cancel()
                        ex.shutdown(cancel_futures=True)

            # ---------- Track best (for fallback) ----------
            if best_rank_seen > best["rank"]:
                best["rank"]   = best_rank_seen
                best["bundle"] = (A_S, b_S, A_T, z0_R, vector(F2, best_point) if best_point else None, degs)

            # ---------- Success path: finish instance ----------
            if success is not None:
                x_tuple, rankJ = success
                x_star = vector(F2, x_tuple)

                # Choose b_T so P(x*) = 0
                s_star  = A_S * x_star + b_S
                sK_star = sum(int(s_star[i]) * (a**i) for i in range(n))
                yK_star = F_univar(sK_star)
                yvec_star = vector(F2, K(yK_star)._vector_())
                b_T = A_T * yvec_star

                z_fin = [p + R(int(b_T[i])) for i, p in enumerate(z0_R)]

                # Sanity check
                subst_eval = {x_R[i]: F2(int(x_star[i])) for i in range(n)}
                if not all(p.subs(subst_eval) == _sage_const_0  for p in z_fin):
                    log_write(L, f"[map {amap}] WARNING: P(x*) != 0 after setting b_T. Continuing.")
                    continue

                ensure_dir_for(out_infile)
                with open(out_infile, "w") as f:
                    f.write(", ".join(str(v) for v in x_R) + "\n")
                    f.write("2\n")
                    for p in z_fin: f.write(str(p) + "\n")
                    for v in x_R:   f.write(f"{v}^2 + {v}\n")

                log_write(L, f"[map {amap}] success with rank {rankJ}")
                log_write(L, f"OUTPUT: {out_infile}")
                log_write(L, f"Field modulus: {modulus}")
                log_write(L, f"Public degs: {degs}")
                log_write(L, f"Secret: {list(x_star)}")

                if secret_logfile is None:
                    secret_logfile = os.path.join("logs", f"HFE_n{n}_D{D}_secret.txt")
                write_secret_log(secret_logfile, n, K, F_univar, A_S, b_S, A_T, b_T, x_star)

                return {
                    "ok_zero": True, "rankJ": rankJ, "rank_min": rank_min,
                    "A_S": A_S, "b_S": b_S, "A_T": A_T, "b_T": b_T,
                    "F": F_univar, "modulus": modulus, "secret": x_star,
                    "public_polys": z_fin, "R": R,
                    "have_quad_in_F": have_quad, "have_lin_in_F": have_lin,
                    "public_degrees": degs, "map_attempts": amap,
                    "secret_logfile": secret_logfile
                }

        # ---------- Fallback ----------
        if allow_fallback and best["rank"] >= _sage_const_0  and best["bundle"] is not None:
            A_S, b_S, A_T, z0_R, x_star, degs = best["bundle"]
            if x_star is None:
                raise RuntimeError("Fallback requested but no candidate point was recorded.")
            s_star  = A_S * x_star + b_S
            sK_star = sum(int(s_star[i]) * (a**i) for i in range(n))
            yK_star = F_univar(sK_star)
            yvec_star = vector(F2, K(yK_star)._vector_())
            b_T = A_T * yvec_star
            z_fin = [p + R(int(b_T[i])) for i, p in enumerate(z0_R)]

            subst_eval = {R.gens()[i]: F2(int(x_star[i])) for i in range(n)}
            ok_zero = all(p.subs(subst_eval) == _sage_const_0  for p in z_fin)

            ensure_dir_for(out_infile)
            with open(out_infile, "w") as f:
                f.write(", ".join(str(v) for v in R.gens()) + "\n")
                f.write("2\n")
                for p in z_fin: f.write(str(p) + "\n")
                for v in R.gens(): f.write(f"{v}^2 + {v}\n")

            log_write(L, f"FALLBACK OUTPUT: {out_infile} (rank={best['rank']} < {rank_min})")
            log_write(L, f"Field modulus: {modulus}")
            log_write(L, f"Public degs: {degs}")
            log_write(L, f"Secret: {list(x_star)}")

            if secret_logfile is None:
                secret_logfile = os.path.join("logs", f"HFE_n{n}_D{D}_secret.txt")
            write_secret_log(secret_logfile, n, K, F_univar, A_S, b_S, A_T, b_T, x_star)

            return {
                "ok_zero": ok_zero, "rankJ": best["rank"], "rank_min": rank_min,
                "A_S": A_S, "b_S": b_S, "A_T": A_T, "b_T": b_T,
                "F": F_univar, "modulus": modulus, "secret": x_star,
                "public_polys": z_fin, "R": R,
                "have_quad_in_F": have_quad, "have_lin_in_F": have_lin,
                "public_degrees": degs, "map_attempts": max_maps,
                "secret_logfile": secret_logfile
            }

        raise RuntimeError(f"Failed: best Jacobian rank seen: {best['rank']}.")

    finally:
        if L is not None:
            L.close()

# ============================== MAIN ==========================================

def main():
    if len(sys.argv) < _sage_const_3 :
        print("Usage: sage scripts/construct_HFE_parallelized.sage <n> <D> [outfile.in] [seed] "
              "[prob_quad] [prob_lin] [rank_min] [allow_fallback] [max_maps] [max_secret_tries] [workers] [force]")
        sys.exit(_sage_const_1 )

    n = int(sys.argv[_sage_const_1 ]); D = int(sys.argv[_sage_const_2 ])

    auto_out = os.path.join("data", "hfe_instances", f"HFE_n{n}_D{D}.in")
    if len(sys.argv) >= _sage_const_4 :
        a3 = sys.argv[_sage_const_3 ].strip()
        if _is_unset(a3):
            out_infile = auto_out; arg_offset = _sage_const_4 
        elif a3.isdigit():
            out_infile = auto_out; arg_offset = _sage_const_3   # legacy: treat as seed
        else:
            out_infile = a3; arg_offset = _sage_const_4 
    else:
        out_infile = auto_out; arg_offset = _sage_const_3 

    seed             = _parse_opt(sys.argv, arg_offset+_sage_const_0 , int,   None)
    prob_quad        = _parse_opt(sys.argv, arg_offset+_sage_const_1 , float, _sage_const_0p70 )
    prob_lin         = _parse_opt(sys.argv, arg_offset+_sage_const_2 , float, _sage_const_0p60 )
    rank_min_arg     = sys.argv[arg_offset+_sage_const_3 ] if len(sys.argv) > arg_offset+_sage_const_3  else None
    rank_min         = None if _is_unset(rank_min_arg) else int(rank_min_arg)
    allow_fallback   = _parse_bool(sys.argv[arg_offset+_sage_const_4 ] if len(sys.argv) > arg_offset+_sage_const_4  else None, False)
    max_maps         = _parse_opt(sys.argv, arg_offset+_sage_const_5 , int,   _sage_const_20 )
    max_secret_tries = _parse_opt(sys.argv, arg_offset+_sage_const_6 , int,   _sage_const_2048 )
    workers_arg      = sys.argv[arg_offset+_sage_const_7 ] if len(sys.argv) > arg_offset+_sage_const_7  else None
    force_arg        = sys.argv[arg_offset+_sage_const_8 ] if len(sys.argv) > arg_offset+_sage_const_8  else None

    force = _parse_bool(force_arg, False) or _parse_bool(os.environ.get("HFE_FORCE"), False)

    if (not force) and os.path.exists(out_infile):
        print(f"[{now_str()}] Found existing instance: {out_infile} — skipping. "
              f"(set HFE_FORCE=1 or pass final 'true' to regenerate)")
        return

    workers = pick_workers(workers_arg, max_secret_tries=max_secret_tries, batch_size=_sage_const_256 , n=n)

    logname   = os.path.join("logs", f"HFE_n{n}_D{D}_genlog.txt")
    secretlog = os.path.join("logs", f"HFE_n{n}_D{D}_secret.txt")

    print(f"[{now_str()}] Generating classical HFE instance (n={n}, D={D}) ...")
    print(f"[{now_str()}] Output .in: {out_infile}")
    print(f"[{now_str()}] Workers: {workers}")

    info = build_and_export_instance(
        n, D, out_infile, seed=seed,
        prob_quad=prob_quad, prob_lin=prob_lin,
        max_maps=max_maps, max_secret_tries=max_secret_tries,
        rank_min=rank_min, allow_fallback=allow_fallback,
        logfile=logname, secret_logfile=secretlog, verbose=False,
        workers=workers, batch_size=_sage_const_256 
    )
    print(f"[{now_str()}] Log written to:        {logname}")
    print(f"[{now_str()}] Secret log written to: {info.get('secret_logfile', secretlog)}")
    print(f"[{now_str()}] P(x*)=0: {info['ok_zero']}, rank(J_P(x*))={info['rankJ']}")

if __name__ == "__main__":
    main()

