

# This file was *autogenerated* from the file scripts/extract_solutions_from_lex.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_2 = Integer(2)###############################################################################
# fast_extract_solutions_from_shape_lex.sage
#
# Efficiently extract all solutions from a LEX Gr√∂bner basis in shape position.
# Works for "triangular" systems: e.g. x0 + f0(x1,...,xn), ..., xn-1 + fn-1(xn), g(xn)
# Requirements: SAGE, output from convert_to_lex_fglm.sage
###############################################################################

import sys, os, time

def parse_lex_basis(filename):
    # Returns variables (list), field characteristic (int), and polynomials (list of strings)
    variables, p, polys = None, None, []
    with open(filename, 'r') as f:
        lines = f.readlines()
    for line in lines:
        if line.startswith("# Variables:"):
            variables = [v.strip() for v in line.split(":",_sage_const_1 )[_sage_const_1 ].split(",")]
        elif line.startswith("# Field: GF("):
            p = int(line.split("GF(")[_sage_const_1 ].split(")")[_sage_const_0 ].strip())
        elif line and not line.startswith("#"):
            polys.append(line.strip())
    return variables, p, polys

def is_shape_position(polys, variables):
    """
    Accepts LEX triangular shape:
        x0 + f0(x1,...,xn)
        x1 + f1(x2,...,xn)
        ...
        xn-1 + fn-1(xn)
        g(xn) (univariate)
    """
    n = len(variables)
    for k in range(n-_sage_const_1 ):
        poly = polys[k]
        var = poly.parent().gen(k)
        if poly.degree(var) != _sage_const_1  or str(var) not in [str(v) for v in poly.variables()]:
            return False
    # Last polynomial should be univariate in last variable
    last_poly = polys[-_sage_const_1 ]
    last_var = last_poly.parent().gen(n-_sage_const_1 )
    if len(last_poly.variables()) != _sage_const_1  or str(last_poly.variables()[_sage_const_0 ]) != str(last_var):
        return False
    return True

def main():
    if len(sys.argv) < _sage_const_2 :
        print("Usage: sage fast_extract_solutions_from_shape_lex.sage <LEX_basis_file>")
        sys.exit(_sage_const_1 )
    basisfile = sys.argv[_sage_const_1 ]
    variables, p, poly_strs = parse_lex_basis(basisfile)
    F = GF(p)
    R = PolynomialRing(F, variables)
    # We'll use the ring generators for variable keys
    ring_vars = R.gens()
    polys = [R(s) for s in poly_strs if s]
    n = len(variables)

    # Robust shape position check
    if not is_shape_position(polys, variables):
        print("System is not in shape position. Aborting fast extraction.")
        sys.exit(_sage_const_2 )

    t0 = time.time()

    # Last polynomial is univariate in last variable
    last_poly = polys[-_sage_const_1 ]
    last_var = ring_vars[-_sage_const_1 ]
    # Create univariate polynomial ring for root-finding
    S = PolynomialRing(F, str(last_var))
    # Convert last_poly to univariate in S (by variable renaming)
    last_poly_uni = S(last_poly.subs({last_var: S.gen()}))
    last_roots = last_poly_uni.roots(multiplicities=False)
    solutions = []
    for alpha in last_roots:
        # Build assignment dict using *ring variables* as keys
        assign = {ring_vars[-_sage_const_1 ]: alpha}
        # Backward substitution: each poly solves for its leading variable
        for i in range(n-_sage_const_2 , -_sage_const_1 , -_sage_const_1 ):
            poly = polys[i]
            var = ring_vars[i]
            # Substitute using current assign, solve for var
            try:
                val = -poly.subs(assign)
            except Exception as e:
                print(f"Error substituting in poly {poly} with assign {assign}: {e}")
                raise
            assign[var] = val
        # Return in order of variables
        solution = {str(ring_vars[i]): assign[ring_vars[i]] for i in range(n)}
        solutions.append(solution)

    t1 = time.time()
    print(f"Found {len(solutions)} solutions in {t1-t0:.3f} seconds.")

    # Optionally write solutions to file
    out_file = os.path.splitext(basisfile)[_sage_const_0 ] + "_fastsols.txt"
    with open(out_file, "w") as out:
        for sol in solutions:
            out.write("{" + ", ".join(f"{k}: {v}" for k, v in sol.items()) + "}\n")
    print(f"Solutions saved to {out_file}")

if __name__ == "__main__":
    main()

