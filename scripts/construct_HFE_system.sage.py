

# This file was *autogenerated* from the file scripts/construct_HFE_system.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0p6 = RealNumber('0.6'); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_0p70 = RealNumber('0.70'); _sage_const_0p60 = RealNumber('0.60'); _sage_const_20 = Integer(20); _sage_const_2048 = Integer(2048); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_4 = Integer(4); _sage_const_5 = Integer(5); _sage_const_6 = Integer(6); _sage_const_7 = Integer(7)###############################################################################
# construct_HFE_system.sage  —  Classical HFE instance generator for GF(2)
#
# OUTPUT (pipeline .in, no comments):
#   line 1: x0, x1, ..., x{n-1}
#   line 2: 2
#   next n lines: public equations over GF(2)
#   last n lines: field equations  x_i^2 + x_i
#
# CLASSICAL HFE (char 2):
#   F(X) uses only exponents 2^i  (linearized) and 2^i+2^j with i<j (true HFE quad),
#   subject to 2^i ≤ D and 2^i + 2^j ≤ D.
#
# LOGS:
#   • Regular generation log (progress + summary)
#       logs/HFE_n{n}_D{D}_genlog.txt
#     includes the secret vector as well.
#
#   • NEW: Secret log (parse-friendly details for verification)
#       logs/HFE_n{n}_D{D}_secret.txt
#     contains:
#       Field: GF(2^n)
#       Modulus polynomial: <irreducible poly over GF(2)>
#       F(X) = <polynomial over GF(2^n)[X]>
#       A_S =            # matrix block (one row per line)
#       [ ... ]
#       b_S = ( ... )
#       A_T =
#       [ ... ]
#       b_T = ( ... )
#       Secret = [ ... ]
###############################################################################

import sys, os, time
from random import random
from sage.all import *

# ---------- Utilities ---------------------------------------------------------

def ensure_dir_for(path):
    """Create parent directory for `path`, if needed."""
    d = os.path.dirname(path)
    if d and not os.path.exists(d):
        os.makedirs(d)

def now_str():
    """Wall-clock time string for user-facing messages."""
    return time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())

def log_write(L, s):
    """Write a line to an open log file (if any)."""
    if L is not None:
        L.write(s + "\n"); L.flush()

# ---------- HFE univariate over K = GF(2^n) ----------------------------------

def random_hfe_polynomial(K, n, D, prob_quad=_sage_const_0p6 , prob_lin=_sage_const_0p6 ,
                          must_have_quad=True, must_have_lin=True):
    """
    Build F(X) ∈ K[X] with HFE-degree ≤ D using:
      • linearized terms: X^(2^i) when 2^i ≤ D;
      • TRUE quadratic terms: X^(2^i+2^j) with i<j and 2^i+2^j ≤ D.
    (We exclude i=j because X^(2^i+2^i) = X^(2^{i+1}) in char 2 → linearized.)
    """
    R = PolynomialRing(K, names=('X',)); (X,) = R._first_ngens(1)
    F = R(_sage_const_0 )

    # admissible 2^i
    lin_is = []
    e = _sage_const_1 ; i = _sage_const_0 
    while i < n and e <= D:
        lin_is.append(i)
        i += _sage_const_1 ; e <<= _sage_const_1 

    # admissible 2^i+2^j with i<j
    quad_pairs = []
    for i in range(n):
        e_i = _sage_const_1  << i
        if e_i > D: break
        for j in range(i+_sage_const_1 , n):        # STRICT i<j
            e_ij = e_i + (_sage_const_1  << j)
            if e_ij > D: break
            quad_pairs.append((i, j))

    have_quad = False; have_lin = False

    # pick quadratic terms
    for (i, j) in quad_pairs:
        if random() < prob_quad:
            c = K.random_element()
            if c != _sage_const_0 :
                F += c * X**((_sage_const_1  << i) + (_sage_const_1  << j))
                have_quad = True

    # pick linearized terms
    for i in lin_is:
        if random() < prob_lin:
            c = K.random_element()
            if c != _sage_const_0 :
                F += c * X**(_sage_const_1  << i)
                have_lin = True

    # optional constant
    c0 = K.random_element()
    if c0 != _sage_const_0 :
        F += c0

    # enforce presence if admissible
    if must_have_quad and not have_quad and quad_pairs:
        i, j = quad_pairs[_sage_const_0 ]
        F += K(_sage_const_1 ) * X**((_sage_const_1  << i) + (_sage_const_1  << j))
        have_quad = True
    if must_have_lin and not have_lin and lin_is:
        i = lin_is[_sage_const_0 ]
        F += K(_sage_const_1 ) * X**(_sage_const_1  << i)
        have_lin = True

    return F, have_quad, have_lin

# ---------- Project K[ x ] → n coordinates in F2[ x ] ------------------------

def coords_over_F2(poly_Kx, K, a, n, R_F2):
    """
    Given poly_Kx ∈ K[ x0,...,x{n-1} ], write coefficients in the power basis
    {1,a,...,a^{n-1}} and return [g_0,...,g_{n-1}] with g_t ∈ F2[ x ].
    """
    coords = [R_F2(_sage_const_0 ) for _ in range(n)]
    for mon, coeff in poly_Kx.dict().items():
        # coeff ∈ K; expand on basis (GF(2)-vector of length n)
        cvec = K(coeff)._vector_()
        mon_R = R_F2({mon: _sage_const_1 })
        for t in range(n):
            if cvec[t] != _sage_const_0 :
                coords[t] += mon_R
    return coords

def boolean_reduce(poly, R):
    """
    Correct Boolean reduction modulo <x_i^2 - x_i>:
      for each variable, any exponent e >= 1 collapses to 1 (NOT e mod 2).
    This keeps x^k = x for k>=1 and preserves quadratic products.
    """
    terms = {}
    for mon, coeff in poly.dict().items():
        if coeff == _sage_const_0 :
            continue
        red_mon = tuple(_sage_const_1  if e > _sage_const_0  else _sage_const_0  for e in mon)
        terms[red_mon] = terms.get(red_mon, R.base_ring()(_sage_const_0 )) + coeff
    return R(terms)

# ---------- Jacobian rank -----------------------------------------------------

def jacobian_rank_at(polys, R, x_star):
    """
    Rank over GF(2) of J = (∂p_i/∂x_j)(x_star), where polys ⊂ R and x_star ∈ (GF(2))^n.
    """
    n = len(polys); F2 = R.base_ring(); xs = R.gens()
    J = Matrix(F2, n, n, _sage_const_0 )
    subst = {xs[j]: F2(int(x_star[j])) for j in range(n)}
    for i in range(n):
        for j in range(n):
            dpoly = polys[i].derivative(xs[j])
            J[i, j] = F2(dpoly.subs(subst))
    return J.rank()

# ---------- Secret log writer -------------------------------------------------

def write_secret_log(secret_logfile, n, K, F_univar, A_S, b_S, A_T, b_T, secret_vec):
    """
    Emit a parse-friendly secret log with the exact objects needed for downstream
    verification and equivalence checks.
    """
    ensure_dir_for(secret_logfile)
    with open(secret_logfile, "w") as S:
        S.write(f"Secret log — {now_str()}\n")
        S.write(f"Field: GF(2^{n})\n")
        S.write(f"Modulus polynomial: {K.modulus()}\n")
        S.write(f"F(X) = {F_univar}\n")
        # A_S
        S.write("A_S =\n")
        for i in range(A_S.nrows()):
            S.write("[" + " ".join(str(int(A_S[i,j])) for j in range(A_S.ncols())) + "]\n")
        S.write("b_S = (" + ", ".join(str(int(b)) for b in b_S) + ")\n")
        # A_T
        S.write("A_T =\n")
        for i in range(A_T.nrows()):
            S.write("[" + " ".join(str(int(A_T[i,j])) for j in range(A_T.ncols())) + "]\n")
        S.write("b_T = (" + ", ".join(str(int(b)) for b in b_T) + ")\n")
        # Secret
        S.write("Secret = [" + ", ".join(str(int(b)) for b in secret_vec) + "]\n")

# ---------- Builder: compute in K[x], then project to F2[x] -------------------

def build_and_export_instance(n, D, out_infile, seed=None,
                              prob_quad=_sage_const_0p70 , prob_lin=_sage_const_0p60 ,
                              max_maps=_sage_const_20 , max_secret_tries=_sage_const_2048 ,
                              rank_min=None, allow_fallback=False,
                              logfile=None, secret_logfile=None,
                              verbose=False):
    """
    Conditions:
     (i) F has linearized and TRUE quadratic HFE terms (when admissible).
    (ii) public system has degree ≥ 2 after Boolean reduction.
   (iii) ∃ x* with Jacobian rank ≥ rank_min (default n-1). If not found but
         allow_fallback=True, accept the best-rank seen.

    Writes:
      - .in file for the pipeline
      - generation log (logfile)
      - NEW: secret log (secret_logfile) with F, S, T, secret
    """
    # ---- logging files ----
    L = None
    if logfile:
        ensure_dir_for(logfile)
        L = open(logfile, "w")
        log_write(L, f"HFE generation start — {now_str()}")
        log_write(L, f"Params: n={n}, D={D}, prob_quad={prob_quad}, prob_lin={prob_lin}, "
                     f"max_maps={max_maps}, max_secret_tries={max_secret_tries}, "
                     f"rank_min={'auto' if rank_min is None else rank_min}, "
                     f"allow_fallback={allow_fallback}")

    try:
        if seed is not None:
            set_random_seed(int(seed))
            log_write(L, f"Seed set to {int(seed)}")

        if rank_min is None:
            rank_min = max(_sage_const_0 , n - _sage_const_1 )

        # Base structures
        F2 = GF(_sage_const_2 )
        K = GF(_sage_const_2 **n, names=('a',)); (a,) = K._first_ngens(1)# field for HFE
        modulus = K.modulus()
        names = tuple(f"x{i}" for i in range(n))
        R = PolynomialRing(F2, n, names=names)     # R = F2[x]
        XK = PolynomialRing(K, n, names=names)     # XK = K[x]
        x_R  = R.gens()
        x_K  = XK.gens()

        # Draw F(X) ∈ K[X]
        F_univar, have_quad, have_lin = random_hfe_polynomial(
            K, n, D, prob_quad=prob_quad, prob_lin=prob_lin,
            must_have_quad=True, must_have_lin=True
        )
        log_write(L, f"F has true quadratic? {have_quad}; linearized? {have_lin}")

        def rnd_inv(n, F2):
            while True:
                M = random_matrix(F2, n, n)
                if M.is_invertible():
                    return M

        # For fallback bookkeeping
        best = {"rank": -_sage_const_1 , "bundle": None}  # (A_S,b_S,A_T,z_vec_red0,x_star,degs)

        # Try up to max_maps pairs (S,T)
        for amap in range(_sage_const_1 , max_maps+_sage_const_1 ):
            A_S = rnd_inv(n, F2)
            b_S = vector(F2, [F2.random_element() for _ in range(n)])
            A_T = rnd_inv(n, F2)

            # --- Compute S(x) in K[x] cleanly ---
            s_vec_K = []
            for k in range(n):
                expr = XK(_sage_const_0 )
                for j in range(n):
                    if int(A_S[k, j]) != _sage_const_0 :
                        expr += x_K[j]
                if int(b_S[k]) != _sage_const_0 :
                    expr += _sage_const_1 
                s_vec_K.append(expr)

            # Embed to K via the fixed basis: sK(x) = Σ s_k(x) a^k ∈ K[x]
            sK = sum(s_vec_K[k] * (a**k) for k in range(n))

            # Evaluate the HFE univariate: yK(x) = F( sK(x) ) ∈ K[x]
            yK = F_univar(sK)

            # Project K[x] → n polynomials over F2[x]
            y_vec_R = coords_over_F2(yK, K, a, n, R)

            # Apply output linear map (no constant yet): z0 = A_T * y
            z0_R = []
            for i in range(n):
                acc = R(_sage_const_0 )
                for j in range(n):
                    if int(A_T[i, j]) != _sage_const_0 :
                        acc += y_vec_R[j]
                z0_R.append(acc)

            # Boolean reduction
            z0_R = [boolean_reduce(p, R) for p in z0_R]
            degs = [p.total_degree() for p in z0_R]
            maxdeg = max(degs) if degs else -_sage_const_1 
            log_write(L, f"[map {amap}] public max degree after Boolean: {maxdeg}")

            # Condition (ii): we need degree ≥ 2 publicly
            if not (maxdeg is not None and maxdeg >= _sage_const_2 ):
                log_write(L, f"[map {amap}] skipped: maxdeg < 2")
                continue

            # --- Search secrets for Jacobian rank ≥ rank_min ---
            for t in range(_sage_const_1 , max_secret_tries+_sage_const_1 ):
                x_star = vector(F2, [F2.random_element() for _ in range(n)])
                rankJ = jacobian_rank_at(z0_R, R, x_star)

                if rankJ > best["rank"]:
                    best["rank"] = rankJ
                    best["bundle"] = (A_S, b_S, A_T, z0_R, x_star, degs)

                if rankJ >= rank_min:
                    # Choose b_T so P(x*)=0 (compute at field level)
                    s_star  = A_S * x_star + b_S
                    sK_star = sum(int(s_star[i]) * (a**i) for i in range(n))
                    yK_star = F_univar(sK_star)
                    yvec_star = vector(F2, K(yK_star)._vector_())
                    b_T = A_T * yvec_star

                    # Final public polynomials: z = z0 + b_T
                    z_fin = [p + R(int(b_T[i])) for i, p in enumerate(z0_R)]

                    # Sanity: verify P(x*)=0
                    subst_eval = {x_R[i]: F2(int(x_star[i])) for i in range(n)}
                    if not all(p.subs(subst_eval) == _sage_const_0  for p in z_fin):
                        # extremely unlikely; continue search
                        continue

                    # SUCCESS: write .in, logs, and secret log
                    ensure_dir_for(out_infile)
                    with open(out_infile, "w") as f:
                        f.write(", ".join(str(v) for v in x_R) + "\n")
                        f.write("2\n")
                        for p in z_fin: f.write(str(p) + "\n")
                        for v in x_R:   f.write(f"{v}^2 + {v}\n")

                    # Regular log summary
                    log_write(L, f"[map {amap}] success at secret #{t} with rank {rankJ}")
                    log_write(L, f"OUTPUT: {out_infile}")
                    log_write(L, f"Field modulus: {modulus}")
                    log_write(L, f"Public degs: {degs}")
                    log_write(L, f"Secret: {list(x_star)}")

                    # Secret log (always)
                    if secret_logfile is None:
                        secret_logfile = os.path.join("logs", f"HFE_n{n}_D{D}_secret.txt")
                    write_secret_log(secret_logfile, n, K, F_univar, A_S, b_S, A_T, b_T, x_star)

                    return {
                        "ok_zero": True, "rankJ": rankJ, "rank_min": rank_min,
                        "A_S": A_S, "b_S": b_S, "A_T": A_T, "b_T": b_T,
                        "F": F_univar, "modulus": modulus, "secret": x_star,
                        "public_polys": z_fin, "R": R,
                        "have_quad_in_F": have_quad, "have_lin_in_F": have_lin,
                        "public_degrees": degs, "map_attempts": amap,
                        "secret_logfile": secret_logfile
                    }

        # If we reached here, no success. Try fallback?
        if allow_fallback and best["rank"] >= _sage_const_0  and best["bundle"] is not None:
            A_S, b_S, A_T, z0_R, x_star, degs = best["bundle"]
            s_star  = A_S * x_star + b_S
            sK_star = sum(int(s_star[i]) * (a**i) for i in range(n))
            yK_star = F_univar(sK_star)
            yvec_star = vector(F2, K(yK_star)._vector_())
            b_T = A_T * yvec_star
            z_fin = [p + R(int(b_T[i])) for i, p in enumerate(z0_R)]

            subst_eval = {R.gens()[i]: F2(int(x_star[i])) for i in range(n)}
            ok_zero = all(p.subs(subst_eval) == _sage_const_0  for p in z_fin)

            ensure_dir_for(out_infile)
            with open(out_infile, "w") as f:
                f.write(", ".join(str(v) for v in R.gens()) + "\n")
                f.write("2\n")
                for p in z_fin: f.write(str(p) + "\n")
                for v in R.gens(): f.write(f"{v}^2 + {v}\n")

            log_write(L, f"FALLBACK OUTPUT: {out_infile} (rank={best['rank']} < {rank_min})")
            log_write(L, f"Field modulus: {modulus}")
            log_write(L, f"Public degs: {degs}")
            log_write(L, f"Secret: {list(x_star)}")

            if secret_logfile is None:
                secret_logfile = os.path.join("logs", f"HFE_n{n}_D{D}_secret.txt")
            write_secret_log(secret_logfile, n, K, F_univar, A_S, b_S, A_T, b_T, x_star)

            return {
                "ok_zero": ok_zero, "rankJ": best["rank"], "rank_min": rank_min,
                "A_S": A_S, "b_S": b_S, "A_T": A_T, "b_T": b_T,
                "F": F_univar, "modulus": modulus, "secret": x_star,
                "public_polys": z_fin, "R": R,
                "have_quad_in_F": have_quad, "have_lin_in_F": have_lin,
                "public_degrees": degs, "map_attempts": max_maps,
                "secret_logfile": secret_logfile
            }

        # Hard failure (no fallback or no candidate at all)
        raise RuntimeError(f"Failed: best Jacobian rank seen: {best['rank']}.")

    finally:
        if L is not None:
            L.close()

# ---------- CLI ----------------------------------------------------------------

def main():
    if len(sys.argv) < _sage_const_3 :
        print("Usage: sage scripts/construct_HFE_system.sage <n> <D> [outfile.in] [seed] "
              "[prob_quad] [prob_lin] [rank_min] [allow_fallback] [max_maps] [max_secret_tries]")
        sys.exit(_sage_const_1 )

    n = int(sys.argv[_sage_const_1 ]); D = int(sys.argv[_sage_const_2 ])

    # Output path (treat '', '-', 'default' as auto)
    auto_out = os.path.join("data", "hfe_instances", f"HFE_n{n}_D{D}.in")
    if len(sys.argv) >= _sage_const_4 :
        a3 = sys.argv[_sage_const_3 ].strip()
        if a3 in ("", "-", "default"):
            out_infile = auto_out; arg_offset = _sage_const_4 
        elif a3.isdigit():
            out_infile = auto_out; arg_offset = _sage_const_3   # a3 is seed
        else:
            out_infile = a3; arg_offset = _sage_const_4 
    else:
        out_infile = auto_out; arg_offset = _sage_const_3 

    seed             = int(sys.argv[arg_offset])     if len(sys.argv) >= arg_offset+_sage_const_1  else None
    prob_quad        = float(sys.argv[arg_offset+_sage_const_1 ]) if len(sys.argv) >= arg_offset+_sage_const_2  else _sage_const_0p70 
    prob_lin         = float(sys.argv[arg_offset+_sage_const_2 ]) if len(sys.argv) >= arg_offset+_sage_const_3  else _sage_const_0p60 
    rank_min_arg     = sys.argv[arg_offset+_sage_const_3 ]        if len(sys.argv) >= arg_offset+_sage_const_4  else None
    rank_min         = int(rank_min_arg) if rank_min_arg is not None else None
    allow_fallback   = (sys.argv[arg_offset+_sage_const_4 ].lower() in ("1","true","yes")) if len(sys.argv) >= arg_offset+_sage_const_5  else False
    max_maps         = int(sys.argv[arg_offset+_sage_const_5 ])   if len(sys.argv) >= arg_offset+_sage_const_6  else _sage_const_20 
    max_secret_tries = int(sys.argv[arg_offset+_sage_const_6 ])   if len(sys.argv) >= arg_offset+_sage_const_7  else _sage_const_2048 

    logname    = os.path.join("logs", f"HFE_n{n}_D{D}_genlog.txt")
    secretlog  = os.path.join("logs", f"HFE_n{n}_D{D}_secret.txt")

    print(f"[{now_str()}] Generating classical HFE instance (n={n}, D={D}) ...")
    print(f"[{now_str()}] Output .in: {out_infile}")
    info = build_and_export_instance(
        n, D, out_infile, seed=seed,
        prob_quad=prob_quad, prob_lin=prob_lin,
        max_maps=max_maps, max_secret_tries=max_secret_tries,
        rank_min=rank_min, allow_fallback=allow_fallback,
        logfile=logname, secret_logfile=secretlog, verbose=False
    )
    print(f"[{now_str()}] Log written to:        {logname}")
    print(f"[{now_str()}] Secret log written to: {info.get('secret_logfile', secretlog)}")
    print(f"[{now_str()}] P(x*)=0: {info['ok_zero']}, rank(J_P(x*))={info['rankJ']}")

if __name__ == "__main__":
    main()

