

# This file was *autogenerated* from the file scripts/test_hfe_solution_validity.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_0 = Integer(0); _sage_const_3 = Integer(3)###############################################################################
# test_hfe_solution_validity.sage
#
# PURPOSE
#   Given:
#     • a pipeline .in file (variables, field, public equations, field equations),
#     • a solutions file (one dict-like solution per line),
#     • optionally, a generation/secret log (to recover the planted secret and S),
#   this script verifies, for each candidate solution:
#     (1) whether it satisfies all public equations;
#     (2) whether it satisfies all field equations x_i^2 + x_i (if present);
#     (3) if a secret is available, whether it equals the planted secret;
#     (4) if S is available, whether it is S-equivalent to the secret:
#           A_S * x + b_S == A_S * x* + b_S  over GF(2).
#   Optional flag --rank prints the Jacobian rank at each candidate solution.
#
# USAGE
#   sage scripts/test_hfe_solution_validity.sage <in_file> <solutions_file> [log_file]
#        [--secret v0,v1,...,v{n-1}] [--rank]
#
# SOLUTIONS FORMAT
#   One solution per line, dict-like, e.g.:
#       {x0: 0, x1: 1, x2: 0, x3: 1}
#   Keys may be quoted or not; values must be 0/1 (GF(2)).
###############################################################################

import sys, re, ast
from sage.all import GF, PolynomialRing, Matrix, vector, matrix

# -----------------------------------------------------------------------------
# (0) Small helpers
# -----------------------------------------------------------------------------
def _strip_labels_and_brackets(line):
    """
    Remove an optional 'name =' label and surrounding () or [] brackets.
    Turn e.g. 'b_S = (1, 0, 1)' into '1, 0, 1'.
    """
    s = line.strip()
    if "=" in s:
        s = s.split("=", _sage_const_1 )[_sage_const_1 ].strip()
    return s.replace("(", "").replace(")", "").replace("[", "").replace("]", "").strip()

def _parse_int_list(s):
    """Parse comma/space separated integers from string s."""
    return [int(t) for t in re.split(r"[,\s]+", s) if t != ""]

# -----------------------------------------------------------------------------
# (1) Parse pipeline .in file
# -----------------------------------------------------------------------------
def parse_in_file(infile):
    """
    Returns:
        var_names: list[str]
        F: GF(p) (we expect p=2)
        R: polynomial ring GF(p)[x...]
        public_polys: list of R-polynomials (length n)
        field_polys: list of R-polynomials (length n) or None
    """
    with open(infile, "r") as f:
        lines = [ln.strip() for ln in f if ln.strip()]

    if len(lines) < _sage_const_2 :
        raise ValueError("Malformed .in file (need at least 2 header lines).")

    # Line 1: variable names "x0, x1, ..., x{n-1}"
    var_names = [v.strip() for v in lines[_sage_const_0 ].split(",")]
    n = len(var_names)
    if n == _sage_const_0 :
        raise ValueError("No variables found in first line of .in file.")

    # Line 2: field (accepts "2", "GF(2)", "GF(2^1)")
    fld = lines[_sage_const_1 ]
    if fld == "2":
        p = _sage_const_2 
    elif fld.upper().startswith("GF("):
        inside = fld.split("GF(", _sage_const_1 )[_sage_const_1 ].split(")", _sage_const_1 )[_sage_const_0 ].strip()
        if "^" in inside:
            base, _deg = inside.split("^", _sage_const_1 )
            p = int(base.strip())
        else:
            p = int(inside)
    else:
        p = int(fld)

    F = GF(p)
    R = PolynomialRing(F, var_names, order='lex')
    x = R.gens()

    # Remaining lines: first n are public equations; next n (if present) are field eqs
    eq_lines = lines[_sage_const_2 :]
    if len(eq_lines) < n:
        raise ValueError(f"Expected at least {n} public equations; found {len(eq_lines)}.")

    public_polys = [R(s) for s in eq_lines[:n]]

    field_polys = None
    if len(eq_lines) >= _sage_const_2 *n:
        cand = [R(s) for s in eq_lines[n:_sage_const_2 *n]]
        ok = all(cand[i] == x[i]**_sage_const_2  + x[i] for i in range(n))
        field_polys = cand if ok else None

    return var_names, F, R, public_polys, field_polys

# -----------------------------------------------------------------------------
# (2) Parse solutions file
# -----------------------------------------------------------------------------
def parse_solutions_file(solfile):
    """
    Parse lines like '{x0: 0, x1: 1, ...}' into dicts.
    Accepts optional quotes; ignores other non-solution lines.
    """
    sols = []
    with open(solfile) as f:
        for line in f:
            line = line.strip()
            if not line or "{" not in line or "}" not in line:
                continue
            # Make keys JSON-like: quote bare words before ':'
            fixed = re.sub(r'(\w+)\s*:', r'"\1":', line)
            try:
                d = ast.literal_eval(fixed)
            except Exception:
                continue
            # Normalize values to ints
            sol = {str(k): int(v) for k, v in d.items()}
            sols.append(sol)
    return sols

# -----------------------------------------------------------------------------
# (3) Solution key sanity
# -----------------------------------------------------------------------------
def check_solution_keys(var_names, sol_dict):
    """Return (missing_keys, extra_keys) wrt the expected variable names."""
    ks = set(sol_dict.keys())
    need = set(var_names)
    missing = sorted(need - ks)
    extra   = sorted(ks - need)
    return missing, extra

# -----------------------------------------------------------------------------
# (4) Evaluate equations at a candidate solution (ordered by var_names)
# -----------------------------------------------------------------------------
def eval_polys(polys, R, var_names, sol_dict):
    """
    Evaluate each polynomial at the point specified by sol_dict,
    interpreting values in the ring's base field. Returns list[bool].
    """
    F = R.base_ring()
    vals = tuple(F(int(sol_dict[name])) for name in var_names)  # KeyError -> loud
    return [p(*vals) == _sage_const_0  for p in polys]

# -----------------------------------------------------------------------------
# (5) Parse generator/secret log to recover secret and S (and optionally T)
# -----------------------------------------------------------------------------
def load_secret_and_maps_from_log(logfile):
    """
    Attempt to recover from the log:
        secret_vector : list[int] or None
        A_S : Matrix(GF(2)) or None
        b_S : vector(GF(2)) or None
        A_T : Matrix(GF(2)) or None (optional)
        b_T : vector(GF(2)) or None (optional)

    Supported formats:
      • "Secret: [1,0,1,...]"  or  "Secret = [ ... ]" (also matches "Secret x* = [...]").
      • "A_S =" block (matrix) followed by a line for b_S (with or without "b_S =").
      • "A_T =" block (matrix) followed by a line for b_T (with or without "b_T =").
      • older logs: "Affine input map S(x) = A_S x + b_S:" followed by matrix + vector.
                    (Analogous for T if present.)

    Returns (secret_vector, A_S, b_S, A_T, b_T).
    """
    txt = open(logfile, "r").read()
    lines = txt.splitlines()

    # Secret (both ':' and '=' variants, optionally with 'x*')
    secret = None
    m = re.search(r"Secret(?:\s*x\*)?\s*[:=]\s*\[([01,\s]+)\]", txt, flags=re.IGNORECASE)
    if m:
        secret = _parse_int_list(m.group(_sage_const_1 ).strip())

    # Helper: parse a Sage-style matrix block:
    # [1 0 1]
    # [0 1 1]
    def parse_matrix_block(lines, start):
        rows = []
        i = start
        while i < len(lines) and lines[i].strip().startswith("["):
            row = [int(s) for s in lines[i].strip().replace("[","").replace("]","").split()]
            rows.append(row); i += _sage_const_1 
        return rows, i

    A_S = b_S = A_T = b_T = None

    # Pattern 1: Explicit "A_S =" and "A_T =" blocks
    for i, ln in enumerate(lines):
        if re.match(r"^\s*A_S\s*=", ln):
            rows, j = parse_matrix_block(lines, i+_sage_const_1 )
            if rows:
                A_S = Matrix(GF(_sage_const_2 ), rows)
                # Next non-empty line should be b_S
                while j < len(lines) and not lines[j].strip():
                    j += _sage_const_1 
                if j < len(lines):
                    b_line = _strip_labels_and_brackets(lines[j])
                    b_S = vector(GF(_sage_const_2 ), _parse_int_list(b_line))
            break

    for i, ln in enumerate(lines):
        if re.match(r"^\s*A_T\s*=", ln):
            rows, j = parse_matrix_block(lines, i+_sage_const_1 )
            if rows:
                A_T = Matrix(GF(_sage_const_2 ), rows)
                while j < len(lines) and not lines[j].strip():
                    j += _sage_const_1 
                if j < len(lines):
                    b_line = _strip_labels_and_brackets(lines[j])
                    b_T = vector(GF(_sage_const_2 ), _parse_int_list(b_line))
            break

    # Pattern 2 (older logs) for S only
    if A_S is None:
        for i, ln in enumerate(lines):
            if "Affine input map S(x)" in ln and "A_S" in ln and "b_S" in ln:
                rows, j = parse_matrix_block(lines, i+_sage_const_1 )
                if rows:
                    A_S = Matrix(GF(_sage_const_2 ), rows)
                    while j < len(lines) and not lines[j].strip():
                        j += _sage_const_1 
                    if j < len(lines):
                        b_line = _strip_labels_and_brackets(lines[j])
                        b_S = vector(GF(_sage_const_2 ), _parse_int_list(b_line))
                break

    return secret, A_S, b_S, A_T, b_T

# -----------------------------------------------------------------------------
# (6) S-equivalence test
# -----------------------------------------------------------------------------
def S_equivalent(var_names, sol_dict, secret_vector, A_S, b_S):
    """
    Return True iff A_S * sol + b_S == A_S * secret + b_S over GF(2).
    """
    F2 = GF(_sage_const_2 )
    x_sol = vector(F2, [F2(int(sol_dict[v])) for v in var_names])
    x_sec = vector(F2, [F2(int(b))          for b in secret_vector])
    return (A_S * x_sol + b_S) == (A_S * x_sec + b_S)

# -----------------------------------------------------------------------------
# (7) Optional: Jacobian rank at a point
# -----------------------------------------------------------------------------
def jacobian_rank_at_point(polys, R, var_names, sol_dict):
    """
    Compute rank over GF(p) of the Jacobian of `polys` at the point defined by sol_dict.
    """
    F = R.base_ring()
    x = R.gens()
    vals = tuple(F(int(sol_dict[name])) for name in var_names)
    J = matrix(F, [[p.derivative(xj)(*vals) for xj in x] for p in polys])
    return J.rank()

# -----------------------------------------------------------------------------
# (8) CLI and main routine
# -----------------------------------------------------------------------------
def main():
    if len(sys.argv) < _sage_const_3 :
        print("Usage: sage scripts/test_hfe_solution_validity.sage <in_file> <solutions_file> [log_file] "
              "[--secret v0,v1,...,v{n-1}] [--rank]")
        sys.exit(_sage_const_1 )

    in_file   = sys.argv[_sage_const_1 ]
    sols_file = sys.argv[_sage_const_2 ]

    # Optional: logfile (third positional if not a flag)
    logfile = None
    args = sys.argv[_sage_const_3 :]
    if args and not args[_sage_const_0 ].startswith("-"):
        logfile = args[_sage_const_0 ]
        args = args[_sage_const_1 :]

    # Optional flags
    user_secret = None
    show_rank = False
    i = _sage_const_0 
    while i < len(args):
        if args[i] == "--secret" and i+_sage_const_1  < len(args):
            user_secret = _parse_int_list(args[i+_sage_const_1 ].strip())
            i += _sage_const_2 
        elif args[i] == "--rank":
            show_rank = True
            i += _sage_const_1 
        else:
            print(f"Unrecognized argument: {args[i]}")
            sys.exit(_sage_const_2 )

    # Load system
    var_names, F, R, public_polys, field_polys = parse_in_file(in_file)
    n = len(var_names)

    # Load solutions
    solutions = parse_solutions_file(sols_file)

    # Optional: load secret and maps from log
    secret = A_S = b_S = A_T = b_T = None
    if logfile:
        try:
            secret, A_S, b_S, A_T, b_T = load_secret_and_maps_from_log(logfile)
        except Exception as e:
            print(f"[WARN] Could not parse log '{logfile}': {e}")

    # If user provided --secret, prefer that for equality/S-equivalence checks
    if user_secret is not None:
        secret = user_secret

    # Header
    print("==============================================================")
    print(" HFE SOLUTION VALIDITY CHECK")
    print("==============================================================")
    print(f"System:         {in_file}")
    print(f"Solutions file: {sols_file}")
    if logfile:
        print(f"Log file:       {logfile}")
        print("Parsed from log — "
              f"secret: {'yes' if secret is not None else 'no'}, "
              f"A_S: {'yes' if A_S is not None else 'no'}, "
              f"b_S: {'yes' if b_S is not None else 'no'}, "
              f"A_T: {'yes' if A_T is not None else 'no'}, "
              f"b_T: {'yes' if b_T is not None else 'no'}")
    print(f"Variables: {var_names}  (n={n})")
    print("--------------------------------------------------------------")
    print(f"Found {len(solutions)} solution(s) to test.\n")

    # Process each solution
    for idx, sol in enumerate(solutions, _sage_const_1 ):
        print(f"Solution #{idx}: {sol}")

        # Key sanity
        missing, extra = check_solution_keys(var_names, sol)
        if missing:
            print(f"  [warn] solution missing vars: {missing}")
        if extra:
            print(f"  [warn] solution has extra keys (ignored): {extra}")

        # Public equations
        ok_pub = eval_polys(public_polys, R, var_names, sol)
        print(f"  Satisfies public equations? {'YES' if all(ok_pub) else 'NO'}")
        if not all(ok_pub):
            bad = [k+_sage_const_1  for k,b in enumerate(ok_pub) if not b]
            print(f"    Failing eq indices: {bad}")

        # Field equations (if present)
        if field_polys is not None:
            ok_field = eval_polys(field_polys, R, var_names, sol)
            print(f"  Satisfies field equations x_i^2+x_i? {'YES' if all(ok_field) else 'NO'}")
            if not all(ok_field):
                badf = [k+_sage_const_1  for k,b in enumerate(ok_field) if not b]
                print(f"    Failing field eq indices: {badf}")
        else:
            print("  Field equations not present (or not recognized) in .in — skipped.")

        # Equality to planted secret (if available)
        if secret is not None:
            vals = [int(sol[v]) for v in var_names]
            is_secret = (vals == [int(b) for b in secret])
            print(f"  Equals planted secret? {'YES' if is_secret else 'NO'}")
        else:
            print("  Secret not provided/found — equality test skipped.")

        # S-equivalence (if S, b_S, secret available)
        if secret is not None and A_S is not None and b_S is not None:
            try:
                eqS = S_equivalent(var_names, sol, secret, A_S, b_S)
                print(f"  S-equivalent to secret (A_S x + b_S)? {'YES' if eqS else 'NO'}")
            except Exception as e:
                print(f"  S-equivalence check failed: {e}")
        else:
            print("  S-equivalence not checked (missing S or secret).")

        # Optional Jacobian rank (public system only)
        if show_rank:
            try:
                r = jacobian_rank_at_point(public_polys, R, var_names, sol)
                print(f"  Jacobian rank at this solution: {r} / {n}")
            except Exception as e:
                print(f"  Jacobian rank computation failed: {e}")

        print()

    print("--------------------------------------------------------------")
    print("Validation complete.")

# Entry point
if __name__ == "__main__":
    main()

