###############################################################################
# solve_F4_from_file.jl
#
# This script reads a system of polynomial equations from a file, constructs the
# corresponding ideal over a finite field, and computes a Gröbner basis using
# the F4 algorithm (as implemented in AlgebraicSolving.jl). Results and logs are
# written to disk. The script supports parallel computation via user-specified
# number of threads.
###############################################################################


using AlgebraicSolving  # Provides tools for polynomial rings, ideals, F4 algorithm, etc.
import Base.Filesystem: mkpath
using Dates

##########################
# 1. Parse command-line arguments
##########################
function parse_args()
    # The script expects at least 1 argument: the input filename.
    # Optionally, a second argument specifies the number of computation threads.
    if length(ARGS) < 1
        println("Usage: julia solve_F4_from_file.jl <inputfile> [nthreads]")
        exit(1)
    end
    filename = ARGS[1]
    nthreads = length(ARGS) >= 2 ? parse(Int, ARGS[2]) : 1  # Default: 1 thread
    return filename, nthreads
end

filename, nthreads = parse_args()

# Ensure output directories for logs and results exist
mkpath("logs")
mkpath("results")

##########################
# 2. Parse input file
##########################
lines = readlines(filename)  # Read all lines into a vector of strings
var_names = [strip(v) for v in split(strip(lines[1]), ",")]  # Expect first line to be variable names, separated by commas (e.g., "x, y, z")

# Second line: finite field specification, either "p" (prime field) or "p^n" (extension)
field_spec = strip(lines[2])
if occursin("^", field_spec)
    base, ext = split(field_spec, "^")
    p = parse(Int, strip(base))  # Characteristic
    n = parse(Int, strip(ext))  # Degree of extension
    K = GF(p, n, "a")  # Construct the finite field GF(p^n), primitive element "a"
    field_desc = "GF($p^$n)"
else
    p = parse(Int, field_spec)
    n = 1
    K = GF(p)
    field_desc = "GF($p)"
end

# Construct the multivariate polynomial ring R = K[var_names]
R, vars = polynomial_ring(K, var_names)

# For each variable, bind its symbol in Main so polynomials can be parsed/evaluated from strings
for (i, v) in enumerate(var_names)
    @eval Main $(Symbol(v)) = vars[$i]
end

# Initialize an array for the system's polynomials
polys = Vector{typeof(vars[1])}()
# Parse each subsequent line as a polynomial in R, push into polys
for line in lines[3:end]
    try
        poly = eval(Meta.parse(line))
        push!(polys, poly)
    catch err
        println("Error evaluating polynomial: $line")
        rethrow(err)
    end
end

# Form the ideal generated by the polynomials: I = <polys>
I = Ideal(polys)

##########################
# 3. Prepare output/log file names
##########################
input_id = splitext(basename(filename))[1]
timestamp = Dates.format(now(), "yyyymmdd_HHMMSS")

log_file = "logs/$(input_id)_F4_$timestamp.log"
result_file = "results/$(input_id)_F4_$timestamp.txt"

##########################
# 4. Compute Gröbner basis and log all output
##########################
open(log_file, "w") do logio
    redirect_stdout(logio) do
        redirect_stderr(logio) do
            # Report basic information
            println("Loaded system with $(length(var_names)) variables and $(length(polys)) equations over $field_desc")
            println("Using $nthreads threads for computation.")

            # Compute Gröbner basis using the F4 algorithm (Faugère 1999)
            # info_level=2 provides moderate verbosity for debugging; nr_thrds sets the number of threads.
            @time G = groebner_basis(I; info_level=2, nr_thrds=nthreads)
            println("\nComputed Groebner basis (F4):")
            for g in G
                println(g)
            end
            
            # Verify that the computed basis G is indeed a Gröbner basis for I.
            # This is done by reducing each generator of I modulo the ideal and ensuring the normal form is zero.
            for f in getfield(I, :gens)
                r = normal_form(f, I)
                @assert r == 0
            end
            println("\nThe computed Groebner basis is correct!")
            # Save the result in a human-readable text file
            open(result_file, "w") do fio
                println(fio, "# Groebner basis (F4) computed for $(filename)")
                println(fio, "# Variables: ", join(var_names, ", "))
                println(fio, "# Field: $field_desc")
                println(fio, "# Number of input equations: $(length(polys))")
                println(fio, "# --- Groebner basis ---")
                for g in G
                    println(fio, g)
                end
            end
        end
    end
end

println("Computation done. Log: $log_file   Result: $result_file")
